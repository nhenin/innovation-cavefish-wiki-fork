# Setup phases

All zk-SNARKs require some sort of public parameters to be generated first. However, there are different type of setups that can be classified according to two dimensions:

* **Transparent vs. Trusted:** determines if the public parameters of the setup must be derived from some private parameters (trusted) or if they can be directly sampled from some distribution (transparent), without private data involved. The private parameters are commonly referred to as toxic waste. If the private parameters are exposed, security is broken (it normally allows a malicious prover to forge fake proofs). The part of the setup that involves the private parameters can be executed by a single Trusted Third Party or, commonly in practice, by a set of distrustful parties running a Secure Multi-Party Computation (MPC) process, where none of the parties learns the full private value.
* **Universal vs. Circuit-Specific:** determines if the public parameters from a setup can be reused to generate proofs on different circuits or, on the contrary, a special circuit-specific setup phase must be run independently for each circuit. Note that, even when a universal setup can be reused for different circuits, some SNARKs still require to derive a proving/verifying key pair from each specific circuit to be used.

From a usability point of view, protocols with transparent and universal setups are the most versatile ones because they enable an easier handling of different circuits without re-runing setup steps or relying on private parameters. However, this normally comes at the cost of having slower proof systems. Some illustrative examples are presented below, with asymptotic costs relative to the circuit size:

| **Protocol** | **Setup** | **Prover time** | **Verifier time** | **Proof size** |
| ------------ | --------- | --------------- | ----------------- | -------------- |
| Groth16 | Trusted / Circuit-Specific | linear | linear (w.r.t. public statement x) | constant |
| Halo2 (KZG) | Trusted / Universal | quasi-linear | linear (w.r.t. public statement x) | constant |
| Halo2 (IPA) | Transparent / Universal | linear | logarithmic | logarithmic |
| Bulletproofs | Transparent / Universal | quasi-linear | linear | logarithmic |

A high-level representation of how different types of setups are used is presented in the following diagram.

<img width="781" height="461" alt="Setups" src="https://github.com/user-attachments/assets/6f499dd3-2e15-4b24-9757-dab10b41f585" />

# The case of Cavefish

In Cavefish, the zk-SNARK takes as private input the complete transaction generated by the SP and computes a set of verifications about it, to let the LC being ensured that the transaction fulfills the desired intent. 

It should be noted that transactions’ sizes can vary depending on the fields they include, since some of them are optional and only included for some type of transactions. In addition, even when a specific transaction type is fixed and when Cavefish relies on its Tx-level strategy (i.e., when almost all verifications are done off-circuit), the number of inputs in a transaction is still variable (inputs are kept secret the whole time). This implies that modifying the number of inputs to be used also modifies the circuit structure (which depends, on a first approach, on the transaction length), and therefore the need of having different setups generated when using some protocols such as Groth16, or at least generating a specific pair of proving/verifying keys for each circuit when using Halo 2.

Because all the previous, design decisions that impact usage and performance must be made. Two main design strategies are identified:

* **Buffered inputs:** a common approach when working with circuits that require handling variable-sized inputs is to use a fixed-length buffer. The input is always parsed to `MAX-LEN` (with dummy data) and fed into the buffer, which is understood as the actual input by the circuit. However, this introduces two caveats: (1) useless delays due to the computation applied to dummy data, which is exacerbated when the difference between `MAX-LEN` and the real length of data is large, and (2) additional difficulty for computing on the real data and omit the dummy one (additional details below), which is normally translated into more delays.
* **On-demand setups:** this approach assumes that each time a different circuit is needed, the corresponding setup is available or computed at that time. In the first case, the main caveat is that the number of setups to be pre-computed can be very large depending on the number of different transaction type, number of inputs, etc. to be supported. In the second case, executing the setup at the time needed is not realistic because of the delays introduced, and overall if the setup is trusted, which normally implies having an MPC run.

It should be noted that using the buffered inputs approach with a single circuit that can handle the maximum length possible for a Cardano transaction can lead to huge and unacceptable delays for most of the cases, where transactions are expected to be much smaller. While the second approach is also unrealistic (mainly because most ready-to-use libraries rely on protocols with some sort of toxic waste), it seems interesting to target a mixed approach, where a certain number of setups are pre-computed and buffered inputs are handled for just a small set of inputs per circuit.

<img width="471" height="231" alt="Buffered-circuits" src="https://github.com/user-attachments/assets/4142918e-31ad-4c4f-a1ba-4a4d95cf1fa2" />

## Hashing issues

There is another difficulty to consider when designing the circuits in Cavefish, which is also related to the variable-size nature of transactions.

The common approach of using buffers to handle variable-sized inputs inside circuits may imply a modification in the way that actual computations are executed and therefore, their results. Let’s consider the basic computation to obtain `txId=Hash(txBody)`. One could design the circuit in a way that the input to the hash block is always of length `MAX-LEN`, e.g., as `input=txBody||zeroes`. However, the added zeroes affect the result, i.e., computing an incorrect `txId`. It should be noted that modifying how `txId` is computed in Cardano such that it always uses a zero-padded input of length `MAX-LEN` is not realistic. Therefore, the approach to be done in-circuit when using a padding strategy should be the following:

* Include a private input `len` that determines the real length of the input.
* For each one of the possible transaction length `i` that fits within a buffer of `MAX-LEN` (e.g., transactions from 1 to 10 inputs), compute a result `r_i`. Then, based on the private input `len`, determine which of the results is the correct one. This must be done in this inefficient way because of the deterministic nature of circuits. Since there is no conditional branching, all possible computations must be carried out and the desired result can be selected by using a binary selector trick for branching: `result=\sum_i(s_i*r_i)`, where `s_i` is the ith value of a binary vector that contains all 0s and a single 1 (the desired branch).

Notice that this approach highly conditions performance if the number of branches to be handled by a single circuit is large. Therefore, some trade-off must be done between minimizing the options supported by each circuit (faster proofs but additional number of circuits and setups) and minimizing the number of circuits and setups (buffers with more options, therefore slower proofs).